###观察者和更新绑定

正如目前在这章看到的，你访问的变量，以及域或方法调用结果，能够填充视图属性。这是有趣的，但是它可能还是没有让你接受数据绑定。虽然有一些较小的代码维护的优点，但是简直不值得。

数据绑定真正闪耀的地方是当你访问的变量，以及域或方法调用结果是可观察对象的时候（例如实现android.databinding.Observable的那个）。然后，表达式不仅在布局资源inflated的时候更新你的视图属性，也会在数据改变的时候更新。如果你有可观察模型，仅仅更新这些模型对象就会自动传递这些改变到任何存在的在观察这些模型的视图上。

例如，假定你在写任务管理清单的时候。用户可以点击CheckBox控件来指示这个特定任务完成了，在这个时候你想要处了更新展现任务的模型对象之外，还要改变整个任务它的RecyclerView行中的绘制。因为CheckBox是相同行的一部分，是和行的模型绑定的，在相同的onClickListener中同时处理UI更新和模型更新可能是容易的。但是，如果你想要在模型改变已经被存储到数据库或网络的时候才更新绘制呢？现在，在onClickListener返回的任意毫秒数过后，你需要更新RecyclerView的某些行...如果正好有行指向这个模型对象。最终，用户可能滑动，或者甚至彻底地离开这个RecyclerView，在此情形中原本的行不应该被改变。

明显的折衷是定义你的模型对象让它使用观察者。稍微不明显的折衷是重新组织你的代码让其有持久模型对象，在这个地方我们进行网络服务服务调用并更新这些模型对象，而不是用新建的实例来取代这些模型对象。后一种方法总的来说打破了数据绑定，并且它在尝试从这些模型更新你的UI的时候就是个大得多的问题了。

####可观察基本类型

####可观察域

####可观察ArrayList和可观察ArrayMap

####自定义可观察者

####TODO



