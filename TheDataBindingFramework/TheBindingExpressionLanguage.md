###绑定表达式语言

基本相似的，你可以在布局资源中使用的绑定表达式语言正如它的Java对应部分一样。如果你可以把它包含进一个Java表达式，你就可以把它包含进一个绑定表达式。这个不仅包含了你典型的算数，逻辑以及字符串拼接操作，也包含了:

* Casts转化
* 为分组使用()（例如，@｛（（Location）(restraurant.location)）.latitude｝)
* 调用方法，在表达式中的对象和导入类的静态方法上调用
* 通过名称访问域，在对象和你导入的静态类上
* 使用<>标志访问数组内容，包含使用如索引的其它变量（例如，@{movie.actor[index].fullName}）
* 对于内联的if样式的分支使用三元运算（例如,@{movie.isNew?View.VISIBLE:View.GONE}）

####你不会在Java找到的东西

表达式语言包含一些超出你会在标准Java中看到的东西。

其中一个已经提到过的:JavaBean样式存取器的使用。所以，foo.bar会尝试在foo对象上找一个
叫做bar的域。如果这个域没有找到，foo.bar会尝试在foo对象上找到一个getBar()方法。这允许模型对象决定是通过域暴露数据还是使用getter()方法，绑定表达式两种情况都能用。

如果你的对象是一个Map，你可以使用<>标志来通过key访问map,而必要调用get()。

如果你在空对象上访问一个域或者调用一个方法，你通常会得到一个空指针异常。表达式评估器尝试缓和这个问题：

* 如果域或方法是设计成返回一些基本数据的，访问这个域的结果或在空值上调用这个方法结果返回的都是默认的基本数据值(例如，int和long类型的值都是0)
* 不然，如果域或方法返回的是一些对象，访问空域或在空上调用方法会返回空。

另一种处理空值的的方式是？？“空合并运算符”。表达式foo？？bar,结果是:

* foo,如果foo不是空的
* bar,如果foo是空的

党可选值为空，而你想要用一个默认值替换一些可选的值，这是很用用的。例如，你可以使用sub.expirationData??@string/not_yet_subscribed来展示一些订阅的过期时间或在没有过期日期的情况下拉取字符串资源的值来使用。

这个例子展示了另一个表达式语言特性：对资源的引用。通常来说，你不会使用数据绑定系统来引用它们。所以，这些是等价的:

* android:text="@string/foo"
* android:text="@{@string/foo}"

当然，在真实的表达式上使用这些资源的时候作用显示出来了,例如对一个布尔值资源进行三目运算(例如,@{@boolean/i_can_haz_foo?foo:bar})。

注意一些资源类型在绑定表达式中使用了不同的名称，因为表达式评估器需要知道数据类型。所以，例如，你通常你仅仅以@array/name来引用数组资源。在绑定表达式中，你用不同的标识取代@array从而来指示类型，例如@stringArray或intArray。

####警告

当然，所有都是简单的，那就不是Android了...

####处理字符串常量

数字产量和空在表达式中的使用是足够简单的。字符串常量久变的有意思了，因为标准的Java引号系统是和默认的xml用于属性值的引号冲突的。你可选的有:

* 对	XML属性使用单引号，那么你就能在字符串常量上使用双引号（例如，andorid:text='@@{foo["bar"]}'）
* 使用反引号来限定字符串(例如，android:text="@{foo[`bar`]}")
* 使用HTML样式的&quot,使用实体来限定字符串(例如，android:text="@{foo[&quot;bar&quot;]")

以上三个，就可读性而言最后一个是最坏的选择。

####当心整型的误译

假定你想要TextView的android:text属性持有从变量拉取的一个数字值。你可能尝试使用类似android:text="@{question.score}"的东西，在这里score是一个整型。

当你尝试这个的时候，你会在运行时闪退，错误指示没有某个16进制值ID的资源，这个16进制值恰好是你的分数。

这是因为android:text支持字符串或字符串资源。分数的整型值被译为一个对字符串资源的引用，而不是转换成它本身的字符串。

你然后可能尝试android:text="@{question.score.toString()}"。这是不能通过编译的，如果分数是一个int,因为Java基本类型不支持方法，更不用说toString()了。

####其它警告

因为这个东西出现在XML文本中，你会需要把所有在表达式中的<或>符号各自转义为&lt;和&gt，那就有点恼人了。

你不能使用new 操作符来创建对象。但是调用恰好创建新对象的方法是被欢迎的。所以，紧要关头
，当你想要通过new来实例化的时候创建你自己的工厂方法，在这个方法中创建对象。总而言之，你在布局绑定中实例化的对象越多，绑定就会变的越慢，特别是对于像快速滚动列表中的行这样的再三infalted的布局而言。

你不能访问this或者super，因为这些会参考生成的绑定类本身。











