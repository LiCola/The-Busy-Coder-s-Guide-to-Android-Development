###碎片和多个Acticity

一个碎片应该能够完全在碎片本身内部处理好功能。所有碎片外部的东西就应该由调用碎片的activity负责了。
例如，如果用户点击了ListFragment上的一项，这个事件的效果会超出ListFragment本身，ListFragment应该传递这个事件到宿主activity,那么它就能执行另外的步骤了(例如，启动一个activity，更新另一个由activity持有的碎片)。

正如我们会在之后章回看到的，我们碎片中的一些会被多个不同的activity持有。例如，在一个案例中我们会让一个碎片被
一个为大屏设计的activity所持有，在另一个案例中被为小屏而设计的activity所持有。

在这些案例中，fragment在编译时不知道会被哪个activity所持有。对于这些案例，你主要有三个选择：

1.让这些activity实现一个共有的接口，并且让fragment为这个接口强制转换调用getActivity()的结果，
那么它就能在宿主activity上调用方法，而不用去知道它的具体实现。

2.让这些activity通过一个setter()方法提供一个有着共有接口的监听者对象给fragment，并让fragment使用监听者来发起事件等等。

3.使用一个事件总线，我们之后会在这本书中讲到。

当我们在稍后那章进入大屏策略的时候，我们会看到更多关于这个主题的内容。



