###主应用线程

当你在`TextView`上调用`setText()`的时候，你可能认为屏幕是马上被你所提供的文本更新的。

那你就弄错了。

而实际上，所有基于控件UI的修改都会经由一个消息队列。对`setText()`的调用并没有更新屏幕-它们
仅仅是放置了一个消息在一个队列上，告诉操作系统要更新屏幕。操作系统将这些消息从这个队列中弹出，
并且做了消息所要求的事情。

这个队列是用一个线程进行处理的，又称“主应用线程”或”UI线程"。只要这个线程能保持处理消息的状态，
屏幕就会被更新，用户输入等操作就会被处理。

但是，主应用线程也被你activity中几乎所有的回调使用。你的onCreate(),onClick(),onListItemClick(),
以及相类似的方法都是在主应用线程中被调用的。当你的代码执行在这些方法中的时候，Android并没有处理
位于队列中的消息，并且所以屏幕没有更新，用户输入等操作没有被处理。

这当然是糟糕的。很糟糕，如果你在主应用线程上花费了超过几秒的时间来做一些工作话，
Android就可能会显示出令人生畏的“应用无应答”对话框，并且你的activity可能会被杀死。

尽管如此，现如今更令人担忧的是`jank`。

Android中所使用的"Jank"指的是缓慢的UI更新，尤其是有动画的时候。例如，你可能已经遇到过一些
这样的应用，当你滚动应用中的`ListView`的时候，`ListView`并没有很平滑的滚动。而是，滚动地很不平稳，
交织着一段快速移动，移动过程中是没有动画的。大都数情况下，这是由于应用的作者在主应用线程做了
太多工作而造成的。

Android 4.1 中引入了“Project Butter”,其中建立了一个“在应用主线程做太多工作”的基准线。
如果每帧花费了超过16ms的时间，我们就会掉帧，掉帧就是`jank`的源头。因为我们可能在一帧中被调用
很多次，我们的每个调用需要是十分便宜的，最好是1ms以下。我们会在这本书[随后内容](/FindingandEliminatingJank/README.md)
中看到更多有关`jank`的内容，但是现在要理解的是主线程上代码执行过程中的任何明显的延迟对用户来
说都是可见的。

因此，你要确保你所有在主应用线程的工作都是能很快就完成的。这就意味着任何缓慢的都应该在一个
后台线程中去完成而不要捆绑到主应用线程上去。这包含像以下的东西:

1. 网络访问，例如发送数据到一个Web服务或者下载一张图片

2. 大量的文件操作，因为有时闪存会是非常慢的

3. 任何形式的复杂计算

幸运的是，Android支持线程使用来自Java的标准线程类，外加所有你所能预料的装箱和控制结构，例如
java.util.concurrent类包。

但是，存在一个大的限制：你不能从后台线程修改UI。你只能从主应用线程修改UI。
如果你从一个后台线程在`TextView`上调用`setText()`,你的应用会闪退，抛出一个指示你在从非UI线程修改UI的异常。

这是一个痛。
