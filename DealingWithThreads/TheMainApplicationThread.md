###主应用线程

当你在一个`TextView`上调用`setText()`的时候，你可能认为屏幕是在当场立刻使用你所提供的文本就进行更新的。

那你就错了。

实际上，所有对基于控件的UI的修改都会经过一个消息队列。对`setText()`的调用没有更新屏幕-它们
只是放置了一个消息到队列中告诉操作系统要更新屏幕。操作系统让这些消息移除队列并做了消息所要求的事情。

这个队列是由单个线程进行处理的，被称为“主应用线程”或”UI线程"。只要这个线程能保持处理消息的状态，
屏幕就会被更新，用户输入等操作就会被处理。

但是，主应用线程也被用作你activity中的几乎所有的回调。你的onCreate(),onClick(),onListItemClick(),以及类似的方法都是在主应用线程中被调用的。当你的代码在这些方法中执行的时候，Android并没有处理队列中的消息，那么屏幕就没有更新，用户输入等操作就不会被处理。

这当然是个糟糕的情况。很糟糕，以至于如果你在主应用线程上花费了超过几秒的时间来做一些工作，Android可能会显示出令人生畏的“应用无应答”对话框，并且你的activity可能会被杀死。

现如今，尽管如此，更大的担忧是`jank`。

Android中的"Jank"指的是动作缓慢的UI更新，特别是有东西在动的时候。例如，你可能遇到过一些这样的应用，
在应用中当你上次滚动`ListView`的时候，`ListView`并没有很平滑的滚动。而是，滚动地很不平稳，交错着一段没有动画的快速移动。大都数情况下，这是由于应用的作者在主应用线程做了太多工作而造成的。

Android 4.1 中引入了“Project Butter”,除了其它东西之外，建立了一个“在应用主线程做太多工作”的基准线。如果每帧花费了超过16ms的时间，我们就会掉帧，掉帧就是`jank`的源头。因为我们可能在一帧中被调用
很多次，我们的每个调用需要时非常便宜的，最好是1ms以下。我们会在后面的内容中看到更多关于jank的内容，
但是现在要理解的是任何代码执行过程中的明显延迟对用户来说都是可见的。

因此，你要确保你所有在主应用线程的工作都是能很快就完成的。这就意味着任何缓慢的都应该在一个后台线程中去完成而不要捆绑到主应用线程上去。这包含像以下的东西:

1. 网络访问，例如发送数据到一个Web service或者下载一张图片

2. 大量的文件操作，因为闪存有时会是非常慢的

3. 任何形式的复杂计算

幸运的是，Android支持来自Java的标准线程类，外加所有你所能想到的封装和控制结构，例如
java.util.concurrent类包。

但是，有一个大的限制：你不能从后台线程修改过UI。你只能从主应用线程修改UI。如果你从一个后台线程在`TextView`上调用`setText()`,你的应用会闪退，抛出一个指示你在从非UI线程修改UI的异常。

这是一个痛。
