###应用：不只是Activity

Activity是从一个名叫Context的的类继承而来的。许多我们在我们activity上调用的方法，像startActivity()就是从Context继承而来的。

但是，activity不是Context唯一相关的子类。例如，之后我们会看到Service。并且有时候我们会看到空白的Context对象，例如在我们在之后涵盖到BroadcastReveicer的时候。

另一个需要注意的Context是Application。当应用被启动的时候一个Application的实例被创建了。Application实例是一个天然单例，在我们的进程中应该确切只有一个Application实例。

通常来说，这个单例是Application本身的实例。但是，如果我们想的话我们可以子类化Application，然后包含一个我们的自定义application类到manifest上<application>元素的android:name属性上。然后，当Android启动我们的应用的时候，
它会创建一个我们所指派的Application子类，而不再是创建一个普通的Application实例。

在任意Context对象上调用getApplicationContext()的时候，我们都能够取得Application对象。getApplication()
会返回一个Context;如果我们需要引用我们所指定的Application子类，我们就需要向下转型返回的Context到合适的类型。

在Android应用中，我们有一些能够使用Application的方法。

第一点，如果我们需要在一个静态数据成员中持有一些其它对象，并且另外的对象是需要一个Context的话，我们就想要它使用Application，而不是Acticity，Service等。因为Application是一个单例，它实际上是“预先泄露的”。我们不能以某种方式让另一个非直接的静态变量应用它从而造成进一步的泄露。相比之下，假定我们有一个保存在activity的静态数据成员。现在，当Activity被摧毁的时候，它（和所有它持有的，像控件和监听器）不能垃圾回收。这就代表了内存泄露。

你可以进一步让Application管理这个静态数据，而不是使用多个独立的单例。这个方法既有优点又有缺点，但是总体来说，Google对这个方法并不感冒。话虽如此，在Application被实例haunted之后onCreate()很快就被调用了，并且你的Application子类可以重载这个方法并使用它来初始化一些全局变量。

但是，尽管Java文档指出Application上有一个表明当应用离开并且我们的进程被终止了onTerminate()方法,但是实际上这个方法从没有被调用过。



